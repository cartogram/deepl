/* tslint:disable */
/* eslint-disable */
/**
 * DeepL API Documentation
 * The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.
 *
 * The version of the OpenAPI document: 2.9.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Glossary,
  GlossarySourceLanguage,
  GlossaryTargetLanguage,
  ListGlossaries200Response,
  ListGlossaryLanguages200Response,
  ListGlossaryLanguages400Response,
} from '../models';
import {
    GlossaryFromJSON,
    GlossaryToJSON,
    GlossarySourceLanguageFromJSON,
    GlossarySourceLanguageToJSON,
    GlossaryTargetLanguageFromJSON,
    GlossaryTargetLanguageToJSON,
    ListGlossaries200ResponseFromJSON,
    ListGlossaries200ResponseToJSON,
    ListGlossaryLanguages200ResponseFromJSON,
    ListGlossaryLanguages200ResponseToJSON,
    ListGlossaryLanguages400ResponseFromJSON,
    ListGlossaryLanguages400ResponseToJSON,
} from '../models';

export interface CreateGlossaryRequest {
    name: string;
    sourceLang: GlossarySourceLanguage;
    targetLang: GlossaryTargetLanguage;
    entries: string;
    entriesFormat: CreateGlossaryEntriesFormatEnum;
}

export interface DeleteGlossaryRequest {
    glossaryId: string;
}

export interface GetGlossaryRequest {
    glossaryId: string;
}

export interface GetGlossaryEntriesRequest {
    glossaryId: string;
    accept?: GetGlossaryEntriesAcceptEnum;
}

/**
 * 
 */
export class ManageGlossariesApi extends runtime.BaseAPI {

    /**
     * Create a Glossary
     */
    async createGlossaryRaw(requestParameters: CreateGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Glossary>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createGlossary.');
        }

        if (requestParameters.sourceLang === null || requestParameters.sourceLang === undefined) {
            throw new runtime.RequiredError('sourceLang','Required parameter requestParameters.sourceLang was null or undefined when calling createGlossary.');
        }

        if (requestParameters.targetLang === null || requestParameters.targetLang === undefined) {
            throw new runtime.RequiredError('targetLang','Required parameter requestParameters.targetLang was null or undefined when calling createGlossary.');
        }

        if (requestParameters.entries === null || requestParameters.entries === undefined) {
            throw new runtime.RequiredError('entries','Required parameter requestParameters.entries was null or undefined when calling createGlossary.');
        }

        if (requestParameters.entriesFormat === null || requestParameters.entriesFormat === undefined) {
            throw new runtime.RequiredError('entriesFormat','Required parameter requestParameters.entriesFormat was null or undefined when calling createGlossary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.sourceLang !== undefined) {
            formParams.append('source_lang', new Blob([JSON.stringify(GlossarySourceLanguageToJSON(requestParameters.sourceLang))], { type: "application/json", }));
                    }

        if (requestParameters.targetLang !== undefined) {
            formParams.append('target_lang', new Blob([JSON.stringify(GlossaryTargetLanguageToJSON(requestParameters.targetLang))], { type: "application/json", }));
                    }

        if (requestParameters.entries !== undefined) {
            formParams.append('entries', requestParameters.entries as any);
        }

        if (requestParameters.entriesFormat !== undefined) {
            formParams.append('entries_format', requestParameters.entriesFormat as any);
        }

        const response = await this.request({
            path: `/glossaries`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GlossaryFromJSON(jsonValue));
    }

    /**
     * Create a Glossary
     */
    async createGlossary(requestParameters: CreateGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Glossary> {
        const response = await this.createGlossaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the specified glossary.
     * Delete a Glossary
     */
    async deleteGlossaryRaw(requestParameters: DeleteGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.glossaryId === null || requestParameters.glossaryId === undefined) {
            throw new runtime.RequiredError('glossaryId','Required parameter requestParameters.glossaryId was null or undefined when calling deleteGlossary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/glossaries/{glossary_id}`.replace(`{${"glossary_id"}}`, encodeURIComponent(String(requestParameters.glossaryId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the specified glossary.
     * Delete a Glossary
     */
    async deleteGlossary(requestParameters: DeleteGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGlossaryRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve meta information for a single glossary, omitting the glossary entries.
     * Retrieve Glossary Details
     */
    async getGlossaryRaw(requestParameters: GetGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Glossary>> {
        if (requestParameters.glossaryId === null || requestParameters.glossaryId === undefined) {
            throw new runtime.RequiredError('glossaryId','Required parameter requestParameters.glossaryId was null or undefined when calling getGlossary.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/glossaries/{glossary_id}`.replace(`{${"glossary_id"}}`, encodeURIComponent(String(requestParameters.glossaryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GlossaryFromJSON(jsonValue));
    }

    /**
     * Retrieve meta information for a single glossary, omitting the glossary entries.
     * Retrieve Glossary Details
     */
    async getGlossary(requestParameters: GetGlossaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Glossary> {
        const response = await this.getGlossaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the entries of a single glossary in the format specified by the `Accept` header.
     * Retrieve Glossary Entries
     */
    async getGlossaryEntriesRaw(requestParameters: GetGlossaryEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.glossaryId === null || requestParameters.glossaryId === undefined) {
            throw new runtime.RequiredError('glossaryId','Required parameter requestParameters.glossaryId was null or undefined when calling getGlossaryEntries.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
            headerParameters['Accept'] = String(requestParameters.accept);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/glossaries/{glossary_id}/entries`.replace(`{${"glossary_id"}}`, encodeURIComponent(String(requestParameters.glossaryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * List the entries of a single glossary in the format specified by the `Accept` header.
     * Retrieve Glossary Entries
     */
    async getGlossaryEntries(requestParameters: GetGlossaryEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getGlossaryEntriesRaw(requestParameters, initOverrides);
    }

    /**
     * List all glossaries and their meta-information, but not the glossary entries.
     * List all Glossaries
     */
    async listGlossariesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListGlossaries200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/glossaries`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListGlossaries200ResponseFromJSON(jsonValue));
    }

    /**
     * List all glossaries and their meta-information, but not the glossary entries.
     * List all Glossaries
     */
    async listGlossaries(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListGlossaries200Response> {
        const response = await this.listGlossariesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the list of language pairs supported by the glossary feature.
     * List Language Pairs Supported by Glossaries
     */
    async listGlossaryLanguagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListGlossaryLanguages200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/glossary-language-pairs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListGlossaryLanguages200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the list of language pairs supported by the glossary feature.
     * List Language Pairs Supported by Glossaries
     */
    async listGlossaryLanguages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListGlossaryLanguages200Response> {
        const response = await this.listGlossaryLanguagesRaw(initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateGlossaryEntriesFormatEnum = {
    Tsv: 'tsv',
    Csv: 'csv'
} as const;
export type CreateGlossaryEntriesFormatEnum = typeof CreateGlossaryEntriesFormatEnum[keyof typeof CreateGlossaryEntriesFormatEnum];
/**
 * @export
 */
export const GetGlossaryEntriesAcceptEnum = {
    TextTabSeparatedValues: 'text/tab-separated-values'
} as const;
export type GetGlossaryEntriesAcceptEnum = typeof GetGlossaryEntriesAcceptEnum[keyof typeof GetGlossaryEntriesAcceptEnum];
