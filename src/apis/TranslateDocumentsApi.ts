/* tslint:disable */
/* eslint-disable */
/**
 * DeepL API Documentation
 * The DeepL API provides programmatic access to DeepLâ€™s machine translation technology.
 *
 * The version of the OpenAPI document: 2.9.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DocumentTranslationError,
  Formality,
  GetDocumentStatus200Response,
  GetDocumentStatusRequest,
  SourceLanguage,
  TargetLanguage,
  TranslateDocument200Response,
} from '../models';
import {
    DocumentTranslationErrorFromJSON,
    DocumentTranslationErrorToJSON,
    FormalityFromJSON,
    FormalityToJSON,
    GetDocumentStatus200ResponseFromJSON,
    GetDocumentStatus200ResponseToJSON,
    GetDocumentStatusRequestFromJSON,
    GetDocumentStatusRequestToJSON,
    SourceLanguageFromJSON,
    SourceLanguageToJSON,
    TargetLanguageFromJSON,
    TargetLanguageToJSON,
    TranslateDocument200ResponseFromJSON,
    TranslateDocument200ResponseToJSON,
} from '../models';

export interface DownloadDocumentRequest {
    documentId: string;
    getDocumentStatusRequest: GetDocumentStatusRequest;
}

export interface GetDocumentStatusOperationRequest {
    documentId: string;
    getDocumentStatusRequest: GetDocumentStatusRequest;
}

export interface TranslateDocumentRequest {
    targetLang: TargetLanguage;
    file: Blob;
    sourceLang?: SourceLanguage;
    filename?: string;
    formality?: Formality;
    glossaryId?: string;
}

/**
 * 
 */
export class TranslateDocumentsApi extends runtime.BaseAPI {

    /**
     * Once the status of the document translation process is `done`, the result can be downloaded.   For privacy reasons the translated document is automatically removed from the server once it was downloaded and cannot be downloaded again.
     * Download Translated Document
     */
    async downloadDocumentRaw(requestParameters: DownloadDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling downloadDocument.');
        }

        if (requestParameters.getDocumentStatusRequest === null || requestParameters.getDocumentStatusRequest === undefined) {
            throw new runtime.RequiredError('getDocumentStatusRequest','Required parameter requestParameters.getDocumentStatusRequest was null or undefined when calling downloadDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-www-form-urlencoded';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/document/{document_id}/result`.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetDocumentStatusRequestToJSON(requestParameters.getDocumentStatusRequest),
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Once the status of the document translation process is `done`, the result can be downloaded.   For privacy reasons the translated document is automatically removed from the server once it was downloaded and cannot be downloaded again.
     * Download Translated Document
     */
    async downloadDocument(requestParameters: DownloadDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the current status of a document translation process. If the translation is still in progress, the estimated time remaining is also included in the response.
     * Check Document Status
     */
    async getDocumentStatusRaw(requestParameters: GetDocumentStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDocumentStatus200Response>> {
        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getDocumentStatus.');
        }

        if (requestParameters.getDocumentStatusRequest === null || requestParameters.getDocumentStatusRequest === undefined) {
            throw new runtime.RequiredError('getDocumentStatusRequest','Required parameter requestParameters.getDocumentStatusRequest was null or undefined when calling getDocumentStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-www-form-urlencoded';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const response = await this.request({
            path: `/document/{document_id}`.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetDocumentStatusRequestToJSON(requestParameters.getDocumentStatusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDocumentStatus200ResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the current status of a document translation process. If the translation is still in progress, the estimated time remaining is also included in the response.
     * Check Document Status
     */
    async getDocumentStatus(requestParameters: GetDocumentStatusOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDocumentStatus200Response> {
        const response = await this.getDocumentStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call uploads a document and queues it for translation. The call returns once the upload is complete, returning a document ID and key which can be used to [query the translation status](https://www.deepl.com/docs-api/documents/get-document-status) and to [download the translated document](https://www.deepl.com/docs-api/documents/download-document) once translation is complete.    Because the request includes a file upload, it must be an HTTP POST request with content type `multipart/form-data`.   Please be aware that the uploaded document is automatically removed from the server once the translated document has been downloaded. You have to upload the document again in order to restart the translation.   The maximum upload limit for documents is [available here](https://support.deepl.com/hc/articles/360020582359-Document-formats) and may vary based on API plan and document type.   You may specify the glossary to use for the document translation using the `glossary_id` parameter. **Important:** This requires the `source_lang` parameter to be set and the language pair of the glossary has to match the language pair of the request.
     * Upload and Translate a Document
     */
    async translateDocumentRaw(requestParameters: TranslateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TranslateDocument200Response>> {
        if (requestParameters.targetLang === null || requestParameters.targetLang === undefined) {
            throw new runtime.RequiredError('targetLang','Required parameter requestParameters.targetLang was null or undefined when calling translateDocument.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling translateDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // auth_header authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.sourceLang !== undefined) {
            formParams.append('source_lang', new Blob([JSON.stringify(SourceLanguageToJSON(requestParameters.sourceLang))], { type: "application/json", }));
                    }

        if (requestParameters.targetLang !== undefined) {
            formParams.append('target_lang', new Blob([JSON.stringify(TargetLanguageToJSON(requestParameters.targetLang))], { type: "application/json", }));
                    }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.filename !== undefined) {
            formParams.append('filename', requestParameters.filename as any);
        }

        if (requestParameters.formality !== undefined) {
            formParams.append('formality', new Blob([JSON.stringify(FormalityToJSON(requestParameters.formality))], { type: "application/json", }));
                    }

        if (requestParameters.glossaryId !== undefined) {
            formParams.append('glossary_id', requestParameters.glossaryId as any);
        }

        const response = await this.request({
            path: `/document`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TranslateDocument200ResponseFromJSON(jsonValue));
    }

    /**
     * This call uploads a document and queues it for translation. The call returns once the upload is complete, returning a document ID and key which can be used to [query the translation status](https://www.deepl.com/docs-api/documents/get-document-status) and to [download the translated document](https://www.deepl.com/docs-api/documents/download-document) once translation is complete.    Because the request includes a file upload, it must be an HTTP POST request with content type `multipart/form-data`.   Please be aware that the uploaded document is automatically removed from the server once the translated document has been downloaded. You have to upload the document again in order to restart the translation.   The maximum upload limit for documents is [available here](https://support.deepl.com/hc/articles/360020582359-Document-formats) and may vary based on API plan and document type.   You may specify the glossary to use for the document translation using the `glossary_id` parameter. **Important:** This requires the `source_lang` parameter to be set and the language pair of the glossary has to match the language pair of the request.
     * Upload and Translate a Document
     */
    async translateDocument(requestParameters: TranslateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TranslateDocument200Response> {
        const response = await this.translateDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
